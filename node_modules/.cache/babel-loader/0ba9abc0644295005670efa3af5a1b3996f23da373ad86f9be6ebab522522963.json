{"ast":null,"code":"import _createClass from \"/Users/shazil/Downloads/vantajs-globe-example-2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/shazil/Downloads/vantajs-globe-example-2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/shazil/Downloads/vantajs-globe-example-2/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/shazil/Downloads/vantajs-globe-example-2/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport ShaderBase, { VANTA } from './_shaderBase.js';\nvar Effect = /*#__PURE__*/function (_ShaderBase) {\n  _inherits(Effect, _ShaderBase);\n  var _super = _createSuper(Effect);\n  function Effect() {\n    _classCallCheck(this, Effect);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(Effect);\n}(ShaderBase);\nexport default VANTA.register('CLOUDS', Effect);\nEffect.prototype.defaultOptions = {\n  backgroundColor: 0xffffff,\n  skyColor: 0x68b8d7,\n  // 0x99b5bf,\n  cloudColor: 0xadc1de,\n  cloudShadowColor: 0x183550,\n  sunColor: 0xff9919,\n  // 0x1a9eaa\n  sunGlareColor: 0xff6633,\n  sunlightColor: 0xff9933,\n  // 0x1a9eaa\n  scale: 3,\n  scaleMobile: 12,\n  speed: 1,\n  mouseEase: true\n};\nEffect.prototype.fragmentShader = \"uniform vec2 iResolution;\\nuniform vec2 iMouse;\\nuniform float iTime;\\nuniform sampler2D iTex;\\n\\nuniform float speed;\\nuniform vec3 skyColor;\\nuniform vec3 cloudColor;\\nuniform vec3 cloudShadowColor;\\nuniform vec3 sunColor;\\nuniform vec3 sunlightColor;\\nuniform vec3 sunGlareColor;\\nuniform vec3 backgroundColor;\\n\\n// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\\n// uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\\n\\n\\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\\nfloat iqhash( float n ){\\n    return fract(sin(n)*3758.5453);\\n    // return fract(n * (n-1.203) * (n-2.3) / 43758.5453);\\n}\\n\\nfloat noise( vec3 x ){\\n    // The noise function returns a value in the range -1.0f -> 1.0f\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f       = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*57.0 + 113.0*p.z;\\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\\n}\\n\\nconst float constantTime = 1000.;\\nfloat map5( in vec3 p ){\\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\\n    vec3 q = p - speed1*(iTime + constantTime);\\n    float f;\\n    f  = 0.50000*noise( q ); q = q*2.02;\\n    f += 0.25000*noise( q ); q = q*2.03;\\n    f += 0.12500*noise( q ); q = q*2.01;\\n    f += 0.06250*noise( q ); q = q*2.02;\\n    f += 0.03125*noise( q );\\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\\n}\\nfloat map4( in vec3 p ){\\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\\n    vec3 q = p - speed1*(iTime + constantTime);\\n    float f;\\n    f  = 0.50000*noise( q ); q = q*2.02;\\n    f += 0.25000*noise( q ); q = q*2.03;\\n    f += 0.12500*noise( q ); q = q*2.01;\\n    f += 0.06250*noise( q );\\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\\n}\\nfloat map3( in vec3 p ){\\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\\n    vec3 q = p - speed1*(iTime + constantTime);\\n    float f;\\n    f  = 0.50000*noise( q ); q = q*2.02;\\n    f += 0.25000*noise( q ); q = q*2.03;\\n    f += 0.12500*noise( q );\\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\\n}\\nfloat map2( in vec3 p ){\\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\\n    vec3 q = p - speed1*(iTime + constantTime);\\n    float f;\\n    f  = 0.50000*noise( q ); q = q*2.02;\\n    f += 0.25000*noise( q );\\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\\n}\\n\\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\\n\\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t ){\\n    // lighting\\n    vec3 lin = cloudColor*1.4 + sunlightColor*dif;\\n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), cloudShadowColor, den ), den );\\n    col.xyz *= lin;\\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\\n    // front to back blending\\n    col.a *= 0.4;\\n    col.rgb *= col.a;\\n    return sum + col*(1.0-sum.a);\\n}\\n\\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.075,0.02*t); }\\n\\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px ){\\n    vec4 sum = vec4(0.0);\\n\\n    float t = 0.0;\\n\\n    MARCH(20,map5);\\n    MARCH(25,map4);\\n    MARCH(30,map3);\\n    MARCH(40,map2);\\n\\n    return clamp( sum, 0.0, 1.0 );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\\n    vec3 cw = normalize(ta-ro);\\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\\n    vec3 cu = normalize( cross(cw,cp) );\\n    vec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px ){\\n    // background sky\\n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\\n    vec3 col = skyColor - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\\n    col += 0.2*sunColor*pow( sun, 8.0 );\\n\\n    // clouds\\n    vec4 res = raymarch( ro, rd, col, px );\\n    col = col*(1.0-res.w) + res.xyz;\\n\\n    // sun glare\\n    col += 0.2*sunGlareColor*pow( sun, 3.0 );\\n\\n    return vec4( col, 1.0 );\\n}\\n\\nvoid main(){\\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/ iResolution.y;\\n\\n    vec2 m = iMouse.xy/iResolution.xy;\\n    m.y = (1.0 - m.y) * 0.33 + 0.28; // camera height\\n\\n    m.x *= 0.25;\\n    m.x += sin(iTime * 0.1 + 3.1415) * 0.25 + 0.25;\\n\\n    // camera\\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x))); // origin\\n    vec3 ta = vec3(0.0, -1.0, 0.0);\\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n    // ray\\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\\n\\n    gl_FragColor = render( ro, rd, ivec2(gl_FragCoord-0.5) );\\n}\\n\";","map":{"version":3,"names":["ShaderBase","VANTA","Effect","register","prototype","defaultOptions","backgroundColor","skyColor","cloudColor","cloudShadowColor","sunColor","sunGlareColor","sunlightColor","scale","scaleMobile","speed","mouseEase","fragmentShader"],"sources":["/Users/shazil/Downloads/vantajs-globe-example-2/node_modules/vanta/src/vanta.clouds.js"],"sourcesContent":["import ShaderBase, {VANTA} from './_shaderBase.js'\n\nclass Effect extends ShaderBase {}\nexport default VANTA.register('CLOUDS', Effect)\n\nEffect.prototype.defaultOptions = {\n  backgroundColor: 0xffffff,\n  skyColor: 0x68b8d7, // 0x99b5bf,\n  cloudColor: 0xadc1de,\n  cloudShadowColor: 0x183550,\n  sunColor: 0xff9919, // 0x1a9eaa\n  sunGlareColor: 0xff6633,\n  sunlightColor: 0xff9933, // 0x1a9eaa\n  scale: 3,\n  scaleMobile: 12,\n  speed: 1,\n  mouseEase: true,\n}\n\nEffect.prototype.fragmentShader = `\\\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nuniform float iTime;\nuniform sampler2D iTex;\n\nuniform float speed;\nuniform vec3 skyColor;\nuniform vec3 cloudColor;\nuniform vec3 cloudShadowColor;\nuniform vec3 sunColor;\nuniform vec3 sunlightColor;\nuniform vec3 sunGlareColor;\nuniform vec3 backgroundColor;\n\n// uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n// uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube\n\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering\nfloat iqhash( float n ){\n    return fract(sin(n)*3758.5453);\n    // return fract(n * (n-1.203) * (n-2.3) / 43758.5453);\n}\n\nfloat noise( vec3 x ){\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\n}\n\nconst float constantTime = 1000.;\nfloat map5( in vec3 p ){\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\n    vec3 q = p - speed1*(iTime + constantTime);\n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p ){\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\n    vec3 q = p - speed1*(iTime + constantTime);\n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p ){\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\n    vec3 q = p - speed1*(iTime + constantTime);\n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p ){\n    vec3 speed1 = vec3(0.5,0.01,1.0) * 0.5 * speed;\n    vec3 q = p - speed1*(iTime + constantTime);\n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );\n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t ){\n    // lighting\n    vec3 lin = cloudColor*1.4 + sunlightColor*dif;\n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), cloudShadowColor, den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending\n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.075,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px ){\n    vec4 sum = vec4(0.0);\n\n    float t = 0.0;\n\n    MARCH(20,map5);\n    MARCH(25,map4);\n    MARCH(30,map3);\n    MARCH(40,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px ){\n    // background sky\n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 col = skyColor - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n    col += 0.2*sunColor*pow( sun, 8.0 );\n\n    // clouds\n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n\n    // sun glare\n    col += 0.2*sunGlareColor*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid main(){\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.y = (1.0 - m.y) * 0.33 + 0.28; // camera height\n\n    m.x *= 0.25;\n    m.x += sin(iTime * 0.1 + 3.1415) * 0.25 + 0.25;\n\n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x))); // origin\n    vec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n\n    gl_FragColor = render( ro, rd, ivec2(gl_FragCoord-0.5) );\n}\n`\n"],"mappings":";;;;AAAA,OAAOA,UAAU,IAAGC,KAAK,QAAO,kBAAkB;AAAA,IAE5CC,MAAM;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;AAAA,EAASF,UAAU;AAC/B,eAAeC,KAAK,CAACE,QAAQ,CAAC,QAAQ,EAAED,MAAM,CAAC;AAE/CA,MAAM,CAACE,SAAS,CAACC,cAAc,GAAG;EAChCC,eAAe,EAAE,QAAQ;EACzBC,QAAQ,EAAE,QAAQ;EAAE;EACpBC,UAAU,EAAE,QAAQ;EACpBC,gBAAgB,EAAE,QAAQ;EAC1BC,QAAQ,EAAE,QAAQ;EAAE;EACpBC,aAAa,EAAE,QAAQ;EACvBC,aAAa,EAAE,QAAQ;EAAE;EACzBC,KAAK,EAAE,CAAC;EACRC,WAAW,EAAE,EAAE;EACfC,KAAK,EAAE,CAAC;EACRC,SAAS,EAAE;AACb,CAAC;AAEDd,MAAM,CAACE,SAAS,CAACa,cAAc,sxJAoJ9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}